{"version":3,"file":"index.cjs","sources":["../src/Matchers.ts","../src/CalledWithFn.ts","../src/Mock.ts"],"sourcesContent":["type MatcherFn<T> = (actualValue: T) => boolean\n\n// needs to be a class so we can instanceof\nclass Matcher<T> {\n    $$typeof: symbol\n    inverse?: boolean\n\n    constructor(\n        readonly asymmetricMatch: MatcherFn<T>,\n        private readonly description: string,\n    ) {\n        this.$$typeof = Symbol.for('vi.asymmetricMatcher')\n    }\n\n    toString() {\n        return this.description\n    }\n\n    toAsymmetricMatcher() {\n        return this.description\n    }\n\n    getExpectedType() {\n        return 'undefined'\n    }\n}\n\nclass CaptorMatcher<T> {\n    $$typeof: symbol\n    public readonly asymmetricMatch: MatcherFn<T>\n    public readonly value!: T\n    public readonly values: T[] = []\n    constructor() {\n        this.$$typeof = Symbol.for('vi.asymmetricMatcher')\n\n        this.asymmetricMatch = (actualValue: T) => {\n            // @ts-ignore\n            this.value = actualValue\n            this.values.push(actualValue)\n            return true\n        }\n    }\n\n    getExpectedType() {\n        return 'Object'\n    }\n\n    toString() {\n        return 'captor'\n    }\n\n    toAsymmetricMatcher() {\n        return 'captor'\n    }\n}\n\ninterface MatcherCreator<T, E = T> {\n    (expectedValue?: E): Matcher<T>\n}\n\ntype MatchersOrLiterals<Y extends any[]> = { [K in keyof Y]: Matcher<Y[K]> | Y[K] }\n\nconst any: MatcherCreator<any> = () => new Matcher(() => true, 'any()')\nconst anyBoolean: MatcherCreator<boolean> = () => new Matcher((actualValue: boolean) => typeof actualValue === 'boolean', 'anyBoolean()')\nconst anyNumber: MatcherCreator<number> = () =>\n    new Matcher((actualValue) => typeof actualValue === 'number' && !isNaN(actualValue), 'anyNumber()')\nconst anyString: MatcherCreator<string> = () => new Matcher((actualValue: string) => typeof actualValue === 'string', 'anyString()')\nconst anyFunction: MatcherCreator<Function> = () =>\n    new Matcher((actualValue: Function) => typeof actualValue === 'function', 'anyFunction()')\nconst anySymbol: MatcherCreator<symbol> = () => new Matcher((actualValue) => typeof actualValue === 'symbol', 'anySymbol()')\nconst anyObject: MatcherCreator<any> = () =>\n    new Matcher((actualValue) => typeof actualValue === 'object' && actualValue !== null, 'anyObject()')\n\nconst anyArray: MatcherCreator<any[]> = () => new Matcher((actualValue) => Array.isArray(actualValue), 'anyArray()')\nconst anyMap: MatcherCreator<Map<any, any>> = () => new Matcher((actualValue) => actualValue instanceof Map, 'anyMap()')\nconst anySet: MatcherCreator<Set<any>> = () => new Matcher((actualValue) => actualValue instanceof Set, 'anySet()')\nconst isA: MatcherCreator<any> = (clazz) => new Matcher((actualValue) => actualValue instanceof clazz, 'isA()')\n\nconst arrayIncludes: MatcherCreator<any[], any> = (arrayVal) =>\n    new Matcher((actualValue) => Array.isArray(actualValue) && actualValue.includes(arrayVal), 'arrayIncludes()')\nconst setHas: MatcherCreator<Set<any>, any> = (arrayVal) =>\n    new Matcher((actualValue) => anySet().asymmetricMatch(actualValue) && actualValue!.has(arrayVal), 'setHas()')\nconst mapHas: MatcherCreator<Map<any, any>, any> = (mapVal) =>\n    new Matcher((actualValue) => anyMap().asymmetricMatch(actualValue) && actualValue!.has(mapVal), 'mapHas()')\nconst objectContainsKey: MatcherCreator<any, string> = (key) =>\n    new Matcher((actualValue) => anyObject().asymmetricMatch(actualValue) && actualValue[key!] !== undefined, 'objectContainsKey()')\nconst objectContainsValue: MatcherCreator<any> = (value) =>\n    new Matcher(\n        (actualValue) => anyObject().asymmetricMatch(actualValue) && Object.values(actualValue).includes(value),\n        'objectContainsValue()',\n    )\n\nconst notNull: MatcherCreator<any> = () => new Matcher((actualValue) => actualValue !== null, 'notNull()')\nconst notUndefined: MatcherCreator<any> = () => new Matcher((actualValue) => actualValue !== undefined, 'notUndefined()')\nconst notEmpty: MatcherCreator<any> = () =>\n    new Matcher((actualValue) => actualValue !== null && actualValue !== undefined && actualValue !== '', 'notEmpty()')\n\nconst captor = <T extends any = any>() => new CaptorMatcher<T>()\nconst matches = <T extends any = any>(matcher: MatcherFn<T>) => new Matcher(matcher, 'matches()')\n\nexport {\n    Matcher,\n    CaptorMatcher,\n    any,\n    anyBoolean,\n    anyNumber,\n    anyString,\n    anyFunction,\n    anySymbol,\n    anyObject,\n    anyArray,\n    anyMap,\n    anySet,\n    isA,\n    arrayIncludes,\n    setHas,\n    mapHas,\n    objectContainsKey,\n    objectContainsValue,\n    notNull,\n    notUndefined,\n    notEmpty,\n    captor,\n    matches,\n}\nexport type { MatcherFn, MatchersOrLiterals, MatcherCreator }\n","import { CalledWithMock } from './Mock'\nimport { Matcher, MatchersOrLiterals } from './Matchers'\nimport { vi, Mock } from 'vitest'\n\ninterface CalledWithStackItem<T, Y extends any[]> {\n    args: MatchersOrLiterals<Y>\n    calledWithFn: Mock<Y, T>\n}\n\ninterface VitestAsymmetricMatcher {\n    asymmetricMatch(...args: any[]): boolean\n}\nfunction isVitestAsymmetricMatcher(obj: any): obj is VitestAsymmetricMatcher {\n    return !!obj && typeof obj === 'object' && 'asymmetricMatch' in obj && typeof obj.asymmetricMatch === 'function'\n}\n\nconst checkCalledWith = <T, Y extends any[]>(\n    calledWithStack: CalledWithStackItem<T, Y>[],\n    actualArgs: Y,\n    fallbackMockImplementation?: FallbackImplementation<Y, T>,\n): T => {\n    const calledWithInstance = calledWithStack.find((instance) =>\n        instance.args.every((matcher, i) => {\n            if (matcher instanceof Matcher) {\n                return matcher.asymmetricMatch(actualArgs[i])\n            }\n\n            if (isVitestAsymmetricMatcher(matcher)) {\n                return matcher.asymmetricMatch(actualArgs[i])\n            }\n\n            return actualArgs[i] === matcher\n        }),\n    )\n\n    // @ts-ignore cannot return undefined, but this will fail the test if there is an expectation which is what we want\n    return calledWithInstance\n        ? calledWithInstance.calledWithFn(...actualArgs)\n        : fallbackMockImplementation && fallbackMockImplementation(...actualArgs)\n}\n\ntype FallbackImplementation<Y extends any[], T> = (...args: Y) => T\ntype CalledWithFnArgs<Y extends any[], T> = { fallbackMockImplementation?: FallbackImplementation<Y, T> }\n\nconst calledWithFn = <T, Y extends any[]>({ fallbackMockImplementation }: CalledWithFnArgs<Y, T> = {}): CalledWithMock<T, Y> => {\n    const fn: Mock<Y, T> = fallbackMockImplementation ? vi.fn(fallbackMockImplementation) : vi.fn()\n    let calledWithStack: CalledWithStackItem<T, Y>[] = []\n\n    ;(fn as CalledWithMock<T, Y>).calledWith = (...args) => {\n        // We create new function to delegate any interactions (mockReturnValue etc.) to for this set of args.\n        // If that set of args is matched, we just call that vi.fn() for the result.\n        const calledWithFn: Mock<Y, T> = fallbackMockImplementation ? vi.fn(fallbackMockImplementation) : vi.fn()\n        const mockImplementation = fn.getMockImplementation()\n        if (\n            !mockImplementation ||\n            fn.getMockImplementation()?.name === 'implementation' ||\n            mockImplementation === fallbackMockImplementation\n        ) {\n            // Our original function gets a mock implementation which handles the matching\n            fn.mockImplementation((...args: Y) => checkCalledWith(calledWithStack, args, fallbackMockImplementation))\n            calledWithStack = []\n        }\n        calledWithStack.unshift({ args, calledWithFn })\n\n        return calledWithFn\n    }\n\n    return fn as CalledWithMock<T, Y>\n}\n\nexport { calledWithFn }\n","import { calledWithFn } from './CalledWithFn'\nimport { MatchersOrLiterals } from './Matchers'\nimport { DeepPartial } from 'ts-essentials'\nimport { Mock, vi } from 'vitest'\n\ntype ProxiedProperty = string | number | symbol\n\ninterface GlobalConfig {\n    // ignoreProps is required when we don't want to return anything for a mock (for example, when mocking a promise).\n    ignoreProps?: ProxiedProperty[]\n}\n\nconst DEFAULT_CONFIG: GlobalConfig = {\n    ignoreProps: ['then'],\n}\n\nlet GLOBAL_CONFIG = DEFAULT_CONFIG\n\nconst VitestMockExtended = {\n    DEFAULT_CONFIG,\n    configure: (config: GlobalConfig) => {\n        // Shallow merge so they can override anything they want.\n        GLOBAL_CONFIG = { ...DEFAULT_CONFIG, ...config }\n    },\n    resetConfig: () => {\n        GLOBAL_CONFIG = DEFAULT_CONFIG\n    },\n}\n\ninterface CalledWithMock<T, Y extends any[]> extends Mock<Y, T> {\n    calledWith: (...args: Y | MatchersOrLiterals<Y>) => Mock<Y, T>\n}\n\ntype _MockProxy<T> = {\n    [K in keyof T]: T[K] extends (...args: infer A) => infer B ? T[K] & CalledWithMock<B, A> : T[K]\n}\n\ntype MockProxy<T> = _MockProxy<T> & T\n\ntype _DeepMockProxy<T> = {\n    // This supports deep mocks in the else branch\n    [K in keyof T]: T[K] extends (...args: infer A) => infer B ? T[K] & CalledWithMock<B, A> : T[K] & _DeepMockProxy<T[K]>\n}\n\n// we intersect with T here instead of on the mapped type above to\n// prevent immediate type resolution on a recursive type, this will\n// help to improve performance for deeply nested recursive mocking\n// at the same time, this intersection preserves private properties\ntype DeepMockProxy<T> = _DeepMockProxy<T> & T\n\ntype _DeepMockProxyWithFuncPropSupport<T> = {\n    // This supports deep mocks in the else branch\n    [K in keyof T]: T[K] extends (...args: infer A) => infer B ? CalledWithMock<B, A> & DeepMockProxy<T[K]> : DeepMockProxy<T[K]>\n}\n\ntype DeepMockProxyWithFuncPropSupport<T> = _DeepMockProxyWithFuncPropSupport<T> & T\n\ninterface MockOpts {\n    deep?: boolean\n    useActualToJSON?: boolean\n    fallbackMockImplementation?: (...args: any[]) => any\n}\n\nconst mockClear = (mock: MockProxy<any>) => {\n    for (const key of Object.keys(mock)) {\n        if (mock[key] === null || mock[key] === undefined) {\n            continue\n        }\n\n        if (mock[key]._isMockObject) {\n            mockClear(mock[key])\n        }\n\n        if (mock[key]._isMockFunction) {\n            mock[key].mockClear()\n        }\n    }\n\n    // This is a catch for if they pass in a vi.fn()\n    if (!mock._isMockObject) {\n        return mock.mockClear()\n    }\n}\n\nconst mockReset = (mock: MockProxy<any>) => {\n    for (const key of Object.keys(mock)) {\n        if (mock[key] === null || mock[key] === undefined) {\n            continue\n        }\n\n        if (mock[key]._isMockObject) {\n            mockReset(mock[key])\n        }\n        if (mock[key]._isMockFunction) {\n            mock[key].mockReset()\n        }\n    }\n\n    // This is a catch for if they pass in a vi.fn()\n    // Worst case, we will create a vi.fn() (since this is a proxy)\n    // below in the get and call mockReset on it\n    if (!mock._isMockObject) {\n        return mock.mockReset()\n    }\n}\n\nfunction mockDeep<T>(\n    opts: {\n        funcPropSupport?: true\n        fallbackMockImplementation?: MockOpts['fallbackMockImplementation']\n    },\n    mockImplementation?: DeepPartial<T>,\n): DeepMockProxyWithFuncPropSupport<T>\nfunction mockDeep<T>(mockImplementation?: DeepPartial<T>): DeepMockProxy<T>\nfunction mockDeep(arg1: any, arg2?: any) {\n    const [opts, mockImplementation] =\n        typeof arg1 === 'object' && (typeof arg1.fallbackMockImplementation === 'function' || arg1.funcPropSupport === true)\n            ? [arg1, arg2]\n            : [{}, arg1]\n    return mock(mockImplementation, { deep: true, fallbackMockImplementation: opts.fallbackMockImplementation })\n}\n\nconst overrideMockImp = (obj: DeepPartial<any>, opts?: MockOpts) => {\n    const proxy = new Proxy<MockProxy<any>>(obj, handler(opts))\n    for (const name of Object.keys(obj)) {\n        if (typeof obj[name] === 'object' && obj[name] !== null) {\n            proxy[name] = overrideMockImp(obj[name], opts)\n        } else {\n            proxy[name] = obj[name]\n        }\n    }\n\n    return proxy\n}\n\nconst handler = (opts?: MockOpts) => ({\n    ownKeys(target: MockProxy<any>) {\n        return Reflect.ownKeys(target)\n    },\n\n    set: (obj: MockProxy<any>, property: ProxiedProperty, value: any) => {\n        obj[property] = value\n        return true\n    },\n\n    get: (obj: MockProxy<any>, property: ProxiedProperty) => {\n        if (!(property in obj)) {\n            if (property === '_isMockObject' || property === '_isMockFunction') {\n                return undefined\n            }\n\n            if (GLOBAL_CONFIG.ignoreProps?.includes(property)) {\n                return undefined\n            }\n            // Jest's internal equality checking does some wierd stuff to check for iterable equality\n            if (property === Symbol.iterator) {\n                return obj[property]\n            }\n\n            if (opts?.useActualToJSON && property === 'toJSON') {\n                return JSON.stringify(obj)\n            }\n\n            // So this calls check here is totally not ideal - jest internally does a\n            // check to see if this is a spy - which we want to say no to, but blindly returning\n            // an proxy for calls results in the spy check returning true. This is another reason\n            // why deep is opt in.\n            const fn = calledWithFn({ fallbackMockImplementation: opts?.fallbackMockImplementation })\n            if (opts?.deep && property !== 'calls') {\n                obj[property] = new Proxy<MockProxy<any>>(fn, handler(opts))\n                obj[property]._isMockObject = true\n            } else {\n                obj[property] = fn\n            }\n        }\n\n        // @ts-ignore\n        if (obj instanceof Date && typeof obj[property] === 'function') {\n            // @ts-ignore\n            return obj[property].bind(obj)\n        }\n\n        return obj[property]\n    },\n})\n\nconst mock = <T, MockedReturn extends MockProxy<T> & T = MockProxy<T> & T>(\n    mockImplementation: DeepPartial<T> = {} as DeepPartial<T>,\n    opts?: MockOpts,\n): MockedReturn => {\n    // @ts-ignore private\n    mockImplementation!._isMockObject = true\n    return overrideMockImp(mockImplementation, opts)\n}\n\nconst mockFn = <\n    T,\n    A extends any[] = T extends (...args: infer AReal) => any ? AReal : any[],\n    R = T extends (...args: any) => infer RReal ? RReal : any,\n>(): CalledWithMock<R, A> & T => {\n    // @ts-ignore\n    return calledWithFn()\n}\n\nconst stub = <T extends object>(): T => {\n    return new Proxy<T>({} as T, {\n        get: (obj, property: ProxiedProperty) => {\n            if (property in obj) {\n                // @ts-ignore\n                return obj[property]\n            }\n            return vi.fn()\n        },\n    })\n}\n\nexport { mock, VitestMockExtended, mockClear, mockReset, mockDeep, mockFn, stub }\nexport type { GlobalConfig, CalledWithMock, MockProxy, DeepMockProxy, MockOpts }\n"],"names":["vi","calledWithFn","args","mock"],"mappings":";;;;;;;;;;AAGA,MAAM,OAAW,CAAA;AAAA,EAIb,WAAA,CACa,iBACQ,WACnB,EAAA;AAFW,IAAA,IAAA,CAAA,eAAA,GAAA,eAAA,CAAA;AACQ,IAAA,IAAA,CAAA,WAAA,GAAA,WAAA,CAAA;AALrB,IAAA,aAAA,CAAA,IAAA,EAAA,UAAA,CAAA,CAAA;AACA,IAAA,aAAA,CAAA,IAAA,EAAA,SAAA,CAAA,CAAA;AAMI,IAAK,IAAA,CAAA,QAAA,GAAW,MAAO,CAAA,GAAA,CAAI,sBAAsB,CAAA,CAAA;AAAA,GACrD;AAAA,EAEA,QAAW,GAAA;AACP,IAAA,OAAO,IAAK,CAAA,WAAA,CAAA;AAAA,GAChB;AAAA,EAEA,mBAAsB,GAAA;AAClB,IAAA,OAAO,IAAK,CAAA,WAAA,CAAA;AAAA,GAChB;AAAA,EAEA,eAAkB,GAAA;AACd,IAAO,OAAA,WAAA,CAAA;AAAA,GACX;AACJ,CAAA;AAEA,MAAM,aAAiB,CAAA;AAAA,EAKnB,WAAc,GAAA;AAJd,IAAA,aAAA,CAAA,IAAA,EAAA,UAAA,CAAA,CAAA;AACA,IAAgB,aAAA,CAAA,IAAA,EAAA,iBAAA,CAAA,CAAA;AAChB,IAAgB,aAAA,CAAA,IAAA,EAAA,OAAA,CAAA,CAAA;AAChB,IAAA,aAAA,CAAA,IAAA,EAAgB,UAAc,EAAC,CAAA,CAAA;AAE3B,IAAK,IAAA,CAAA,QAAA,GAAW,MAAO,CAAA,GAAA,CAAI,sBAAsB,CAAA,CAAA;AAEjD,IAAK,IAAA,CAAA,eAAA,GAAkB,CAAC,WAAmB,KAAA;AAEvC,MAAA,IAAA,CAAK,KAAQ,GAAA,WAAA,CAAA;AACb,MAAK,IAAA,CAAA,MAAA,CAAO,KAAK,WAAW,CAAA,CAAA;AAC5B,MAAO,OAAA,IAAA,CAAA;AAAA,KACX,CAAA;AAAA,GACJ;AAAA,EAEA,eAAkB,GAAA;AACd,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AAAA,EAEA,QAAW,GAAA;AACP,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AAAA,EAEA,mBAAsB,GAAA;AAClB,IAAO,OAAA,QAAA,CAAA;AAAA,GACX;AACJ,CAAA;AAQA,MAAM,MAA2B,MAAM,IAAI,OAAQ,CAAA,MAAM,MAAM,OAAO,EAAA;AAChE,MAAA,UAAA,GAAsC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAyB,KAAA,OAAO,WAAgB,KAAA,SAAA,EAAW,cAAc,EAAA;AACxI,MAAM,SAAoC,GAAA,MACtC,IAAI,OAAA,CAAQ,CAAC,WAAA,KAAgB,OAAO,WAAA,KAAgB,QAAY,IAAA,CAAC,KAAM,CAAA,WAAW,GAAG,aAAa,EAAA;AAChG,MAAA,SAAA,GAAoC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAwB,KAAA,OAAO,WAAgB,KAAA,QAAA,EAAU,aAAa,EAAA;AAC7H,MAAA,WAAA,GAAwC,MAC1C,IAAI,OAAA,CAAQ,CAAC,WAA0B,KAAA,OAAO,WAAgB,KAAA,UAAA,EAAY,eAAe,EAAA;AACvF,MAAA,SAAA,GAAoC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,OAAO,WAAgB,KAAA,QAAA,EAAU,aAAa,EAAA;AACrH,MAAA,SAAA,GAAiC,MACnC,IAAI,OAAQ,CAAA,CAAC,WAAgB,KAAA,OAAO,WAAgB,KAAA,QAAA,IAAY,WAAgB,KAAA,IAAA,EAAM,aAAa,EAAA;AAEjG,MAAA,QAAA,GAAkC,MAAM,IAAI,OAAQ,CAAA,CAAC,gBAAgB,KAAM,CAAA,OAAA,CAAQ,WAAW,CAAA,EAAG,YAAY,EAAA;AAC7G,MAAA,MAAA,GAAwC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,WAAA,YAAuB,KAAK,UAAU,EAAA;AACjH,MAAA,MAAA,GAAmC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,WAAA,YAAuB,KAAK,UAAU,EAAA;AAC5G,MAAA,GAAA,GAA2B,CAAC,KAAU,KAAA,IAAI,QAAQ,CAAC,WAAA,KAAgB,WAAuB,YAAA,KAAA,EAAO,OAAO,EAAA;AAE9G,MAAM,aAA4C,GAAA,CAAC,QAC/C,KAAA,IAAI,QAAQ,CAAC,WAAA,KAAgB,KAAM,CAAA,OAAA,CAAQ,WAAW,CAAK,IAAA,WAAA,CAAY,QAAS,CAAA,QAAQ,GAAG,iBAAiB,EAAA;AAChH,MAAM,SAAwC,CAAC,QAAA,KAC3C,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,MAAA,EAAS,CAAA,eAAA,CAAgB,WAAW,CAAK,IAAA,WAAA,CAAa,GAAI,CAAA,QAAQ,GAAG,UAAU,EAAA;AAChH,MAAM,SAA6C,CAAC,MAAA,KAChD,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,MAAA,EAAS,CAAA,eAAA,CAAgB,WAAW,CAAK,IAAA,WAAA,CAAa,GAAI,CAAA,MAAM,GAAG,UAAU,EAAA;AAC9G,MAAM,oBAAiD,CAAC,GAAA,KACpD,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,SAAA,EAAY,CAAA,eAAA,CAAgB,WAAW,CAAK,IAAA,WAAA,CAAY,GAAI,CAAA,KAAM,QAAW,qBAAqB,EAAA;AAC7H,MAAA,mBAAA,GAA2C,CAAC,KAAA,KAC9C,IAAI,OAAA;AAAA,EACA,CAAC,WAAA,KAAgB,SAAU,EAAA,CAAE,eAAgB,CAAA,WAAW,CAAK,IAAA,MAAA,CAAO,MAAO,CAAA,WAAW,CAAE,CAAA,QAAA,CAAS,KAAK,CAAA;AAAA,EACtG,uBAAA;AACJ,EAAA;AAEE,MAAA,OAAA,GAA+B,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,WAAA,KAAgB,MAAM,WAAW,EAAA;AACnG,MAAA,YAAA,GAAoC,MAAM,IAAI,OAAA,CAAQ,CAAC,WAAgB,KAAA,WAAA,KAAgB,QAAW,gBAAgB,EAAA;AACxH,MAAM,QAAgC,GAAA,MAClC,IAAI,OAAA,CAAQ,CAAC,WAAA,KAAgB,WAAgB,KAAA,IAAA,IAAQ,WAAgB,KAAA,KAAA,CAAA,IAAa,WAAgB,KAAA,EAAA,EAAI,YAAY,EAAA;AAEhH,MAAA,MAAA,GAAS,MAA2B,IAAI,aAAiB,GAAA;AAC/D,MAAM,UAAU,CAAsB,OAAA,KAA0B,IAAI,OAAA,CAAQ,SAAS,WAAW;;ACtFhG,SAAS,0BAA0B,GAA0C,EAAA;AACzE,EAAO,OAAA,CAAC,CAAC,GAAA,IAAO,OAAO,GAAA,KAAQ,YAAY,iBAAqB,IAAA,GAAA,IAAO,OAAO,GAAA,CAAI,eAAoB,KAAA,UAAA,CAAA;AAC1G,CAAA;AAEA,MAAM,eAAkB,GAAA,CACpB,eACA,EAAA,UAAA,EACA,0BACI,KAAA;AACJ,EAAA,MAAM,qBAAqB,eAAgB,CAAA,IAAA;AAAA,IAAK,CAAC,QAC7C,KAAA,QAAA,CAAS,KAAK,KAAM,CAAA,CAAC,SAAS,CAAM,KAAA;AAChC,MAAA,IAAI,mBAAmB,OAAS,EAAA;AAC5B,QAAA,OAAO,OAAQ,CAAA,eAAA,CAAgB,UAAW,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,OAChD;AAEA,MAAI,IAAA,yBAAA,CAA0B,OAAO,CAAG,EAAA;AACpC,QAAA,OAAO,OAAQ,CAAA,eAAA,CAAgB,UAAW,CAAA,CAAC,CAAC,CAAA,CAAA;AAAA,OAChD;AAEA,MAAO,OAAA,UAAA,CAAW,CAAC,CAAM,KAAA,OAAA,CAAA;AAAA,KAC5B,CAAA;AAAA,GACL,CAAA;AAGA,EAAO,OAAA,kBAAA,GACD,mBAAmB,YAAa,CAAA,GAAG,UAAU,CAC7C,GAAA,0BAAA,IAA8B,0BAA2B,CAAA,GAAG,UAAU,CAAA,CAAA;AAChF,CAAA,CAAA;AAKA,MAAM,eAAe,CAAqB,EAAE,0BAA2B,EAAA,GAA4B,EAA6B,KAAA;AAC5H,EAAA,MAAM,KAAiB,0BAA6B,GAAAA,SAAA,CAAG,GAAG,0BAA0B,CAAA,GAAIA,UAAG,EAAG,EAAA,CAAA;AAC9F,EAAA,IAAI,kBAA+C,EAAC,CAAA;AAEnD,EAAC,EAAA,CAA4B,UAAa,GAAA,CAAA,GAAI,IAAS,KAAA;AAGpD,IAAA,MAAMC,gBAA2B,0BAA6B,GAAAD,SAAA,CAAG,GAAG,0BAA0B,CAAA,GAAIA,UAAG,EAAG,EAAA,CAAA;AACxG,IAAM,MAAA,kBAAA,GAAqB,GAAG,qBAAsB,EAAA,CAAA;AACpD,IACI,IAAA,CAAC,sBACD,EAAG,CAAA,qBAAA,IAAyB,IAAS,KAAA,gBAAA,IACrC,uBAAuB,0BACzB,EAAA;AAEE,MAAA,EAAA,CAAG,mBAAmB,CAAIE,GAAAA,KAAAA,KAAY,gBAAgB,eAAiBA,EAAAA,KAAAA,EAAM,0BAA0B,CAAC,CAAA,CAAA;AACxG,MAAA,eAAA,GAAkB,EAAC,CAAA;AAAA,KACvB;AACA,IAAA,eAAA,CAAgB,OAAQ,CAAA,EAAE,IAAM,EAAA,YAAA,EAAAD,eAAc,CAAA,CAAA;AAE9C,IAAOA,OAAAA,aAAAA,CAAAA;AAAA,GACX,CAAA;AAEA,EAAO,OAAA,EAAA,CAAA;AACX;;ACxDA,MAAM,cAA+B,GAAA;AAAA,EACjC,WAAA,EAAa,CAAC,MAAM,CAAA;AACxB,CAAA,CAAA;AAEA,IAAI,aAAgB,GAAA,cAAA,CAAA;AAEpB,MAAM,kBAAqB,GAAA;AAAA,EACvB,cAAA;AAAA,EACA,SAAA,EAAW,CAAC,MAAyB,KAAA;AAEjC,IAAA,aAAA,GAAgB,EAAE,GAAG,cAAgB,EAAA,GAAG,MAAO,EAAA,CAAA;AAAA,GACnD;AAAA,EACA,aAAa,MAAM;AACf,IAAgB,aAAA,GAAA,cAAA,CAAA;AAAA,GACpB;AACJ,EAAA;AAoCM,MAAA,SAAA,GAAY,CAACE,KAAyB,KAAA;AACxC,EAAA,KAAA,MAAW,GAAO,IAAA,MAAA,CAAO,IAAKA,CAAAA,KAAI,CAAG,EAAA;AACjC,IAAA,IAAIA,MAAK,GAAG,CAAA,KAAM,QAAQA,KAAK,CAAA,GAAG,MAAM,KAAW,CAAA,EAAA;AAC/C,MAAA,SAAA;AAAA,KACJ;AAEA,IAAIA,IAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,aAAe,EAAA;AACzB,MAAUA,SAAAA,CAAAA,KAAAA,CAAK,GAAG,CAAC,CAAA,CAAA;AAAA,KACvB;AAEA,IAAIA,IAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,eAAiB,EAAA;AAC3B,MAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,SAAU,EAAA,CAAA;AAAA,KACxB;AAAA,GACJ;AAGA,EAAI,IAAA,CAACA,MAAK,aAAe,EAAA;AACrB,IAAA,OAAOA,MAAK,SAAU,EAAA,CAAA;AAAA,GAC1B;AACJ,EAAA;AAEM,MAAA,SAAA,GAAY,CAACA,KAAyB,KAAA;AACxC,EAAA,KAAA,MAAW,GAAO,IAAA,MAAA,CAAO,IAAKA,CAAAA,KAAI,CAAG,EAAA;AACjC,IAAA,IAAIA,MAAK,GAAG,CAAA,KAAM,QAAQA,KAAK,CAAA,GAAG,MAAM,KAAW,CAAA,EAAA;AAC/C,MAAA,SAAA;AAAA,KACJ;AAEA,IAAIA,IAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,aAAe,EAAA;AACzB,MAAUA,SAAAA,CAAAA,KAAAA,CAAK,GAAG,CAAC,CAAA,CAAA;AAAA,KACvB;AACA,IAAIA,IAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,eAAiB,EAAA;AAC3B,MAAAA,KAAAA,CAAK,GAAG,CAAA,CAAE,SAAU,EAAA,CAAA;AAAA,KACxB;AAAA,GACJ;AAKA,EAAI,IAAA,CAACA,MAAK,aAAe,EAAA;AACrB,IAAA,OAAOA,MAAK,SAAU,EAAA,CAAA;AAAA,GAC1B;AACJ,EAAA;AAUA,SAAS,QAAA,CAAS,MAAW,IAAY,EAAA;AACrC,EAAM,MAAA,CAAC,MAAM,kBAAkB,CAAA,GAC3B,OAAO,IAAS,KAAA,QAAA,KAAa,OAAO,IAAK,CAAA,0BAAA,KAA+B,cAAc,IAAK,CAAA,eAAA,KAAoB,QACzG,CAAC,IAAA,EAAM,IAAI,CACX,GAAA,CAAC,EAAC,EAAG,IAAI,CAAA,CAAA;AACnB,EAAO,OAAA,IAAA,CAAK,oBAAoB,EAAE,IAAA,EAAM,MAAM,0BAA4B,EAAA,IAAA,CAAK,4BAA4B,CAAA,CAAA;AAC/G,CAAA;AAEA,MAAM,eAAA,GAAkB,CAAC,GAAA,EAAuB,IAAoB,KAAA;AAChE,EAAA,MAAM,QAAQ,IAAI,KAAA,CAAsB,GAAK,EAAA,OAAA,CAAQ,IAAI,CAAC,CAAA,CAAA;AAC1D,EAAA,KAAA,MAAW,IAAQ,IAAA,MAAA,CAAO,IAAK,CAAA,GAAG,CAAG,EAAA;AACjC,IAAI,IAAA,OAAO,IAAI,IAAI,CAAA,KAAM,YAAY,GAAI,CAAA,IAAI,MAAM,IAAM,EAAA;AACrD,MAAA,KAAA,CAAM,IAAI,CAAI,GAAA,eAAA,CAAgB,GAAI,CAAA,IAAI,GAAG,IAAI,CAAA,CAAA;AAAA,KAC1C,MAAA;AACH,MAAM,KAAA,CAAA,IAAI,CAAI,GAAA,GAAA,CAAI,IAAI,CAAA,CAAA;AAAA,KAC1B;AAAA,GACJ;AAEA,EAAO,OAAA,KAAA,CAAA;AACX,CAAA,CAAA;AAEA,MAAM,OAAA,GAAU,CAAC,IAAqB,MAAA;AAAA,EAClC,QAAQ,MAAwB,EAAA;AAC5B,IAAO,OAAA,OAAA,CAAQ,QAAQ,MAAM,CAAA,CAAA;AAAA,GACjC;AAAA,EAEA,GAAK,EAAA,CAAC,GAAqB,EAAA,QAAA,EAA2B,KAAe,KAAA;AACjE,IAAA,GAAA,CAAI,QAAQ,CAAI,GAAA,KAAA,CAAA;AAChB,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEA,GAAA,EAAK,CAAC,GAAA,EAAqB,QAA8B,KAAA;AACrD,IAAI,IAAA,EAAE,YAAY,GAAM,CAAA,EAAA;AACpB,MAAI,IAAA,QAAA,KAAa,eAAmB,IAAA,QAAA,KAAa,iBAAmB,EAAA;AAChE,QAAO,OAAA,KAAA,CAAA,CAAA;AAAA,OACX;AAEA,MAAA,IAAI,aAAc,CAAA,WAAA,EAAa,QAAS,CAAA,QAAQ,CAAG,EAAA;AAC/C,QAAO,OAAA,KAAA,CAAA,CAAA;AAAA,OACX;AAEA,MAAI,IAAA,QAAA,KAAa,OAAO,QAAU,EAAA;AAC9B,QAAA,OAAO,IAAI,QAAQ,CAAA,CAAA;AAAA,OACvB;AAEA,MAAI,IAAA,IAAA,EAAM,eAAmB,IAAA,QAAA,KAAa,QAAU,EAAA;AAChD,QAAO,OAAA,IAAA,CAAK,UAAU,GAAG,CAAA,CAAA;AAAA,OAC7B;AAMA,MAAA,MAAM,KAAK,YAAa,CAAA,EAAE,0BAA4B,EAAA,IAAA,EAAM,4BAA4B,CAAA,CAAA;AACxF,MAAI,IAAA,IAAA,EAAM,IAAQ,IAAA,QAAA,KAAa,OAAS,EAAA;AACpC,QAAA,GAAA,CAAI,QAAQ,CAAI,GAAA,IAAI,MAAsB,EAAI,EAAA,OAAA,CAAQ,IAAI,CAAC,CAAA,CAAA;AAC3D,QAAI,GAAA,CAAA,QAAQ,EAAE,aAAgB,GAAA,IAAA,CAAA;AAAA,OAC3B,MAAA;AACH,QAAA,GAAA,CAAI,QAAQ,CAAI,GAAA,EAAA,CAAA;AAAA,OACpB;AAAA,KACJ;AAGA,IAAA,IAAI,eAAe,IAAQ,IAAA,OAAO,GAAI,CAAA,QAAQ,MAAM,UAAY,EAAA;AAE5D,MAAA,OAAO,GAAI,CAAA,QAAQ,CAAE,CAAA,IAAA,CAAK,GAAG,CAAA,CAAA;AAAA,KACjC;AAEA,IAAA,OAAO,IAAI,QAAQ,CAAA,CAAA;AAAA,GACvB;AACJ,CAAA,CAAA,CAAA;AAEA,MAAM,IAAO,GAAA,CACT,kBAAqC,GAAA,IACrC,IACe,KAAA;AAEf,EAAA,kBAAA,CAAoB,aAAgB,GAAA,IAAA,CAAA;AACpC,EAAO,OAAA,eAAA,CAAgB,oBAAoB,IAAI,CAAA,CAAA;AACnD,EAAA;AAEA,MAAM,SAAS,MAIkB;AAE7B,EAAA,OAAO,YAAa,EAAA,CAAA;AACxB,EAAA;AAEA,MAAM,OAAO,MAA2B;AACpC,EAAO,OAAA,IAAI,KAAS,CAAA,EAAS,EAAA;AAAA,IACzB,GAAA,EAAK,CAAC,GAAA,EAAK,QAA8B,KAAA;AACrC,MAAA,IAAI,YAAY,GAAK,EAAA;AAEjB,QAAA,OAAO,IAAI,QAAQ,CAAA,CAAA;AAAA,OACvB;AACA,MAAA,OAAOH,UAAG,EAAG,EAAA,CAAA;AAAA,KACjB;AAAA,GACH,CAAA,CAAA;AACL;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}